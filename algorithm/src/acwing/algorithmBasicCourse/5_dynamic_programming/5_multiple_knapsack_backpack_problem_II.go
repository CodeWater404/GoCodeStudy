package main

/*多重背包大数据，二进制优化：
对于有S件物品，可以按照1、2、4、8...2^k、c来拆分成每一组，拆分要求是所有组之和加起来不超过S，
最后一个常数c严格小于2^(k+1), 如果大于等于的话，还可以拆分到2^(k+1)。
二进制拆分完成后，然后按照01背包来解决，每组选择或者不选择，因为每组的任意组合一定可以表示0~S。

时间复杂度：O(NVlogS)= O(1000 * 2000 * log2000) = O(2000000 * 10) = O(2 * 10^7) 可以过。
如果是朴素多重背包O(NVS) = O(1000 * 2000 * 2000) = O(4 * 10^9) 会超时。

*/

import (
	"fmt"
)

// 最多有物品个数N： 1000 * log2000 = 1000 * 12 = 12000
// 最大体积/容量M:  2010
const N, M = 12010, 2010

var (
	// n种物品 背包容量m
	n, m int
	// 体积 价值
	v, w [N]int
	// f[j]: 对应体积为j能选的最大价值
	f [M]int
)

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	fmt.Scan(&n, &m)

	// 分组个数，按照每种物品个数来分，最终其实就是有cnt种物品选择
	cnt := 0
	for i := 1; i <= n; i++ {
		// 体积 价值 个数
		var a, b, s int
		fmt.Scan(&a, &b, &s)
		// 当前物品数量从1开始分
		k := 1
		// 分下来的数量小于这个物品的总数，继续拆分
		for k <= s {
			cnt++
			// 记录对应组的体积、价值是多少： 当前物品体积是a、价值是b，拆分了k次，一乘就是对应体积价值
			v[cnt], w[cnt] = k*a, k*b
			// s要先减去k，然后k再增长。顺序不要反
			s -= k
			k *= 2
		}
		// 分到最后，s还有一些，但是凑不成2的次方了
		if s > 0 {
			cnt++
			v[cnt], w[cnt] = s*a, s*b
		}
	}

	// n重新赋值，现在一共有cnt组物品，也就是cnt种物品
	n = cnt
	// 到这其实就是01背包，直接用01背包的写法。
	for i := 1; i <= n; i++ {
		for j := m; j >= v[i]; j-- {
			f[j] = max(f[j], f[j-v[i]]+w[i])
		}
	}

	fmt.Println(f[m])
}
