package main

/*
  @author: CodeWater
  @since: 2025/03/05
  @desc: 898. 数字三角形问题
  线性dp： 递推方程具有线性关系，所谓线性就是说我们在计算每一种状态顺序的时候，
对于二维来说是一行一行的求取。
  这个名字不用过于在意，其实就是按照某个特性把dp问题进行分类。

  以下个人感悟思考，不一定对，仅供参考。
  状态表示是一维f[i]还是二维f[i][j]？
	- 直接看要表示的问题背景能不能用一维或者二维来表示出来，如果可以那就是对应的维数。像01背包朴素情况下是二维，但第一维没有用到，进而可以优化成一维。

  状态计算如何求？比如f[i][j]
	- 因为求取的是f[i][j],所以这是未知的，那么我们的思路就是如何从已知表达出未知。
	- 比如f[i-1][j]对于f[i][j]来说就是已知的，那这样的情况下，对于集合的划分里面，能不能把
	所有情况都用f[i-1][j]表达出来呢？如果可以，那就是求出解了。 例子就是前面的背包问题。
	- f[i-1][j]为啥是已知的？我想一个本质原因就是：状态方程的初始状态是已知的，f[0][0] = 0，
	从而后续的状态可以在此状态的基础下递推算出。同时，这样牵扯刀代码的一个写法i一般从1开始，这样
	i-1就是0，不会越界，少一个边界的判断。
*/

import "fmt"

// N数组范围 INF无穷大，1e9是float64，前面加了int做隐式转换
const N, INF int = 510, 1e9

var (
	n    int
	a, f [N][N]int
)

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	fmt.Scan(&n)
	for i := 1; i <= n; i++ {
		for j := 1; j <= i; j++ {
			fmt.Scan(&a[i][j])
		}
	}

	// 边界处理：处理三角形中一些不存在的点
	for i := 0; i <= n; i++ {
		for j := 0; j <= i+1; j++ {
			f[i][j] = -INF
		}
	}

	// 初始状态确定的，就是起点
	f[1][1] = a[1][1]
	// 从第二层开始计算状态
	for i := 2; i <= n; i++ {
		for j := 1; j <= i; j++ {
			// 当前点由左上方、右上方过来，取两者的一个较大值。
			f[i][j] = max(f[i-1][j-1]+a[i][j], f[i-1][j]+a[i][j])
		}
	}

	// 状态计算完之后，看最后一层每个状态的最大值即可。
	res := -INF
	for i := 1; i <= n; i++ {
		res = max(res, f[n][i])
	}
	fmt.Println(res)
}
