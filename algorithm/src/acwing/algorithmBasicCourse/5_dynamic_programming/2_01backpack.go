package __dynamic_programming

/**
  @author: CodeWater
  @since: 2025/02/28
  @desc: 01背包问题
**/

/* 01背包： 朴素二维 */
// import (
// 	"fmt"
// )

// const N = 1010

// var (
// 	// n个物品 背包容量为m
// 	n, m int
// 	// v存每个物品的体积 w存每个物品的价值
// 	v, w [N]int
// 	// f[i][j] = a: 在前i个物品中所选择的总体积小于等于j的最大价值a
// 	f [N][N]int
// )

// func max(a, b int) int {
// 	if a > b {
// 		return a
// 	}
// 	return b
// }

// func main() {
// 	fmt.Scan(&n, &m)
// 	for i := 1; i <= n; i++ {
// 		fmt.Scan(&v[i], &w[i])
// 	}

// 	// f[0][0-m]，不选择物品时的价值是0，而f为包级变量默认数组值就是0，
// 	// 所以这里不用对这个进行初始化

// 	// 直接从1开始
// 	for i := 1; i <= n; i++ {
// 		for j := 0; j <= m; j++ {
// 			f[i][j] = f[i-1][j]
// 			/*本题状态有两种：
// 			  1. f[i - 1][j]: 不选择当前物品，即上面一种恒存在状态，无需判断
// 			  2. f[i][j]: 选择当前物品，前提是当前背包容量得大于当前物品重量，不然下面的回退上一个状态计算当前状态会数组越界f[i-1][j-v[i]]，所以有如下判断。正常应该是j - v[i] >= 0,这里为了方便做了个变形。
// 			*/
// 			if j >= v[i] {
// 				f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i])
// 			}
// 		}
// 	}

// 	fmt.Println(f[n][m])
// }

/* 01背包： 优化成一维。能否优化成一维，主要看状态方程：
1. f[i]这一层只用到了f[i-1]这层，而f[i-2]没有用到f[i-1],所以可以用滚动数组优化。
2. j这个在状态方程中，被用到两个地方f[j]、f[j - v[i]]，也就是这两个地方的值始终小于等于j，在j的一侧，不是在j的两侧，所以可以改成一维来算。
改法：
删除掉一维，然后对相关方程的地方做修改，注意要做等价变形。
*/

import (
	"fmt"
)

const N = 1010

var (
	n, m int
	/* f[i]: 背包容量为 j 时能获得的最大价值 。
	当我们优化到一维后，数组 f[j] 在循环过程中既表示当前层i的状态，也表示上一层i-1的状态。具体来说：
	- 在更新 f[j] 之前， f[j] 存储的是上一层的状态，相当于 f[i-1][j]
	- 更新后， f[j] 存储的是当前层的状态，相当于 f[i][j]
	*/
	v, w, f [N]int
)

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	fmt.Scan(&n, &m)
	for i := 1; i <= n; i++ {
		fmt.Scan(&v[i], &w[i])
	}

	for i := 1; i <= n; i++ {
		/* 变成一维后， f[j]表示的是f[i][j]的值。 因为每次计算 ( f[i][j] ) 时，只需要上一层的状态（注意是上一层i-1！！！不是往前的状态j-v[i]）。通过从大到小遍历 ( j )，确保在计算 ( f[j] ) 时，( f[j-v[i]] ) 仍然是上一层i-1的状态，而不是当前层已经计算过往前的j-v[i]状态。
		 */
		for j := m; j >= v[i]; j-- {
			f[j] = max(f[j], f[j-v[i]]+w[i])
		}
	}
	fmt.Println(f[m])
}
