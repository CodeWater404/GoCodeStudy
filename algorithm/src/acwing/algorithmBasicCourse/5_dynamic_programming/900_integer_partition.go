package main

import (
	"fmt"
)

/*
  @Author: CodeWater
  @since: 2025/03/11
  @desc: 900. 整数划分
	按照完全背包思路来划分状态,f[i][j]前1到 i- 1个整数和是j的方案有多少个；优化成一维f[j]整数和是j。
的有多少个。
*/

// const N, mod = 1010, 1e9 + 7

// var (
// 	n int
// 	// f[j]:是整数j的划分数量
// 	f [N]int
// )

// func main() {
// 	fmt.Scan(&n)

// 	f[0] = 1
// 	for i := 1; i <= n; i++ {
// 		for j := i; j <= n; j++ {
// 			f[j] = (f[j] + f[j-i]) % mod
// 		}
// 	}

// 	fmt.Println(f[n])
// }

/*
按照每个方案中最小的数是否大于1来划分状态,可以划分为两类：
1. 最小值是1的
2. 最小值严格大于1的
*/

const N, mod = 1010, 1e9 + 7

var (
	n int
	// f[i][j]: 总和是i的，恰好用j个数表示的方案数
	f [N][N]int
)

func main() {
	fmt.Scan(&n)

	// 初始状态，总和0用0个数表示的方案数有1个
	f[0][0] = 1
	for i := 1; i <= n; i++ {
		for j := 1; j <= i; j++ {
			/*
			   f[i][j]: 包含两种状态，方案数根据两种状态的上一步状态推算而来。
			   1. 最小值是1的部分：这部分每个方案去掉一个1，每个方案总和是i-1，个数是j-1个，方案数
			   不变。那么此时状态方程可以表示为f[i - 1][j - 1]，也就是说f[i - 1][j - 1]和f[i][j]最
			   小值是1的部分方案数一样。
			   例如，对于总和为5，用3个数表示的方案中，包含数字1的有：
			   - [1,1,3]
			   - [1,2,2]
			   如果从每个方案中移除一个1，就得到：
			   - [1,3] (总和为4，用2个数)
			   - [2,2] (总和为4，用2个数)
			   这正好对应f[4][2]，即f[i-1][j-1]。

			   2. 最小值大于1的部分： 这部分每个方案里面的每个数减掉一个1，每个方案总和变成i-j，但个数
			   不变。此时状态方程f[i-j][j]，也就是对应f[i][j]最小值大于1的部分的方案数。
			   例如，对于总和为7，用3个数表示且所有数字都大于1的方案：
			   - [2,2,3]
			   如果从每个数字中都减去1，就得到：
			   - [1,1,2] (总和为4，仍然用3个数)
			   这对应于f[4][3]，即f[i-j][j]。

			   注意两个部分的方程反向推断的意思。
			*/
			f[i][j] = (f[i-1][j-1] + f[i-j][j]) % mod
		}
	}

	res := 0
	for i := 1; i <= n; i++ {
		res = (res + f[n][i]) % mod
	}
	fmt.Println(res)
}
