package main

/*
  @author: CodeWater
  @since: 2025/03/07
  @desc： 897. 最长公共子序列

  按照a[i]、b[j]是否包含在子序列当中，我们可以划分出四种状态：
   1. f[i - 1][j - 1]（a[i]、b[j]不在子序列当中）: 也就是a[i]和b[j]这两个位置的字母不匹配，依赖于a的前i-1和b的前j-1个字母
      中出现的公共序列。
   2. f[i - 1][j - 1] + 1（a[i]、b[j]在子序列当中）: a[i]和b[j]这两个位置的字母匹配, 这样的情况下用前一种状态+1即可。
   另外两种情况有点特殊。
   3. a[i]不在子序列当中，但是b[j]在， f[i - 1][j]
   4. a[i]在子序列当中，但是b[j]不在， f[i][j - 1]
   这两个状态的特殊点在于状态方程并不完全等价于划分状态的意思，比如第三种情况，a[i]不在b[j]在，方程
   为f[i - 1][j],但实际上这个方程表示的是所有在a前i-1个字母中和在b前j个字母中出现的最长公共子序列，
   并不能保证b的最后一个字母是b[j]，只能保证b[j]这个字母在这个序列中出现过! 也就是说，方程实际表达
   的含义比划分的状态范围要更大一些！
   同理，第四种情况也是一样。但是这里求最长的公共子序列max，3、4两种状态重合没有关系，不影响结果。

   另外，第三、四种情况包含了第一种情况，所以在实际代码的时候，可以不用第一种情况。

*/

import (
	"fmt"
)

const N = 1010

var (
	n, m int
	// 这里目前用的byte数组，也可以采用string来，输入代码会更少一些
	// a, b string
	a, b [N]byte
	// f[i][j]: 所有在a前i个字母中出现，且在b前j个字母中出现的最长公共子序列
	f [N][N]int
)

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	fmt.Scan(&n, &m)
	for i := 1; i <= n; i++ {
		fmt.Scanf("%c", &a[i])
	}
	fmt.Scanf("\n")
	for j := 1; j <= m; j++ {
		fmt.Scanf("%c", &b[j])
	}
	// 如果用string来存储，则需要用下面的代码来输入；然后下面的for循环中，a[i]和b[j]需要改成a[i-1]和b[j-1]
	//fmt.Scan(&a, &b)

	for i := 1; i <= n; i++ {
		for j := 1; j <= m; j++ {
			f[i][j] = max(f[i-1][j], f[i][j-1])
			// 最后一种情况： 只有ij这两个位置的字母相等时f[i-1][j-1]才有效
			if a[i] == b[j] {
				f[i][j] = max(f[i][j], f[i-1][j-1]+1)
			}
		}
	}

	fmt.Println(f[n][m])
}
